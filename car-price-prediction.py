# -*- coding: utf-8 -*-
"""Tubes Statistika Industri.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1itMGFwhlmEQIh9HDorwSWHrMP2pmV4Me

# Car Price Prediction Tubes Statistika Industri

## Load Data

### Connect to google drive and mount it to collab (Make sure dataset for car prediction is there)

place your dataset on /content/drive/MyDive/dataset folder
"""

from google.colab import drive
drive.mount('/content/drive')

"""### Import Needed Library"""

import pandas as pd
import matplotlib.pyplot as plt
from scipy.stats import norm
import scipy.stats as stats
import seaborn as sns
import missingno as msno
import numpy as np
from sklearn.preprocessing import LabelEncoder, MinMaxScaler, StandardScaler
from sklearn.linear_model import LinearRegression
from sklearn.model_selection import train_test_split, GridSearchCV
from sklearn.metrics import mean_squared_error, mean_absolute_error, r2_score
from sklearn.ensemble import RandomForestRegressor
import xgboost as xgb

"""### Load Dataset"""

dataset_location = "/content/drive/MyDrive/dataset/cardekho.csv"
loaded_data = pd.read_csv(dataset_location)
loaded_data

"""## Data Description / Condition for Understanding

### Show Data Information
"""

loaded_data.info()

"""Pada Kolom diatas, terdapat total 12 kolom mulai dari nama mobil, hingga seats yang dimiliki oleh mobil. Adapun penjelasan masing-masing kolom adalah sebagai berikut:

1.   name << Merupakan nama mobil
2.   year << Tahun pembuatan mobil
3. selling_price << Harga jual mobil dalam rupee (indian currency)
4. km_driven << Total kilometer yang ditempuh mobil
5. fuel << Jenis bahan bakar yang digunakan
6. seller_type << Tipe seller, apakah perorangan, dealer, atau yang lainnya
6. transmission << Jenis transmisi mobil, apakah manual atau automatic
7. owner << Jumlah berpindahnya kepemilikan mobil (first owner, second owner)
8. mileage << Efisiensi bahan bakar mobil / berapa banyak liter yang mobil habiskan untuk menempuh jarak dalam satuan kilometer
9. engine << spesifikasi tentang kapasitas mesin mobil untuk mengubah bahan bakar menjadi tenaga penggerak mobil dalam satuan CC
10. max_power << Kecepatan maksimal mobil dalam satuan KM
11. seats << Jumlah seats / kursi yang ada pada mobil

### Check missing value on data for later cleansing
"""

loaded_data.isna().sum()

"""### Check Duplicate"""

loaded_data[loaded_data.duplicated()]

loaded_data.duplicated().sum()

"""### Show data statistics"""

loaded_data.describe().astype(int)

loaded_data.describe(include='object')

"""## Data Visualization

### Univariate analysis

#### Mengubah nama kolom agar memudahkan proses pengolahan dan visualisasi data
"""

loaded_data = loaded_data.rename(columns={ "mileage(km/ltr/kg)": "fuel_eficiency" })
loaded_data

def plot_univariate_data(data, x_label="", y_label="", kind="bar", is_save=False):
  data.value_counts().plot(kind=kind)
  plt.xlabel(x_label if x_label != "" else data.name)
  plt.ylabel(y_label if y_label != "" else "Quantity")
  if(is_save):
    plt.savefig(f"{x_label}.png")
  plt.show()

def plot_univariate_data_in_percent(data):
  data.value_counts(normalize=True).plot(kind="bar")
  plt.xlabel(data.name)
  plt.ylabel("Percentage")
  plt.show()

"""#### Plot total tahun pembuatan masing-masing mobil"""

# plot_univariate_data(loaded_data["year"], "Tahun Pembuatan", "Jumlah")
plot_univariate_data(loaded_data["year"])

print(loaded_data["year"].min(), loaded_data["year"].max())

"""#### Plot Jenis bahan bakar yang digunakan mobil"""

plot_univariate_data(loaded_data["fuel"], "Jenis Bahan Bakar", "Jumlah Mobil")



"""#### Plot Jumlah Seats pada mobil"""

plot_univariate_data(loaded_data["seats"])

"""#### Plot jujmlah total mobil berdasarkan tipe seller"""

plot_univariate_data(loaded_data["seller_type"])

"""#### Plot jumlah perpindahan kepemilikan mobil"""

plot_univariate_data(loaded_data["owner"])

"""#### Plot jenis transimisi yang digunakan oleh mobil"""

plot_univariate_data(loaded_data["transmission"])

loaded_data.describe().astype(int)

"""#### Plot data harga rata-rata per tahun"""

data_groupby_selling_price_mean = loaded_data.groupby("year")["selling_price"].mean()
# plt.scatter(data_groupby_selling_price_mean.index, data_groupby_selling_price_mean)
data_groupby_selling_price_mean.plot(kind="bar")
plt.xlabel("Tahun Pembuatan")
plt.ylabel("Harga Mobil (juta rupee)")
plt.grid(axis="y")
plt.show()

"""Dari grafik di atas, terlihat bahwa harga rata-rata tiap tahun meningkat seiring berjalannya waktu.

#### Plot harga terendah dan tertinggi masing-masing tahun
"""

min_data_per_year = loaded_data.groupby("year")["selling_price"].min()

# plt.scatter(min_data_per_year.index, min_data_per_year)
min_data_per_year.plot(kind="bar")
plt.xlabel("Tahun Pembuatan")
plt.ylabel("Harga Mobil")
plt.show()

max_data_per_year = loaded_data.groupby("year")["selling_price"].max()
max_data_per_year.plot(kind="bar")
plt.xlabel("Tahun Pembuatan")
plt.ylabel("Harga Mobil (puluhan juta rupee)")
plt.show()

plt.show()

"""Dari dua grafik di atas terlihat bahwa harga terendah mobil terletak di tahun 1997, sedangkan harga tertinggi mobil ada pada tahun 2017 dengan nilai 1 x 10e7 / 10.000.000 rupee

#### Plot harga jual mobil berdasarkan fuel
"""

fuel_mean_data = loaded_data.groupby("fuel")["selling_price"].mean()
plt.bar(fuel_mean_data.index, fuel_mean_data)
plt.xlabel("Jenis Bahan Bakar")
plt.ylabel("Harga Jual Mobil")
plt.show()

"""Dari data tersebut terlihat bahwa jenis mobil yang menggunakan bahan bakar diesel cenderung memiliki harga yang lebih tinggi dibanding dengan mobil yang menggunakan jenis bahan bakar lainnya. Hal ini dikarenakan mobil pada dataset ini mayoritas menggunakan jenis bahan bakar diesel dan petrol

#### Plot rata-rata efisiensi bahan bakar berdasarkan transmisi
"""

loaded_data.groupby("transmission")["fuel_eficiency"].mean().plot(kind="bar")
plt.grid(axis="y")
plt.xlabel("Jenis Transmisi")
plt.ylabel("Efisiensi Bahan Bakar (Km/L)")
plt.show()

"""Pada grafik tersebut terlihat bahwa jenis bahan bakar manual lebih efisien daripada jenis transmisi automatic. Hal ini cukup kontradiksi mengingat mobil automatic biasanya lebih efisien dibanding manual. Hal ini disebabkan data yang ada tidak balance, sehingga menyebabkan bias data yang menunjukkan bahwa mobil manual lebih efisien daripada mobil matic

#### Proporsi pemilik pertama untuk mobil dengan transmisi otomatis
"""

owner_distribution = loaded_data.groupby(["transmission", "owner"])["name"].count().unstack()
print(owner_distribution)
count = loaded_data["transmission"].value_counts()
owner_distribution_percent = owner_distribution.div(count, axis=0) * 100
owner_distribution_percent.plot(kind="bar", stacked=True)
plt.xlabel("Jenis Transmisi")
plt.ylabel("Persentase Pemilik")
plt.grid(axis="y")
plt.show()

"""Dari grafik di atas, terlihat bahwa persentase tertinggi penjualan mobil berdasarkan kepemilikan ke-n berdasarkan jenis transmisi yaitu di atas 60%

#### Plot grafik untuk melihat apakah performa mobil masing-masing tipe seller berbeda?
"""

loaded_data.groupby("seller_type")["engine"].mean().plot(kind="bar")
plt.xlabel("Tipe Seller")
plt.ylabel("Performa Mesin (CC)")
plt.show()

"""Terlihat bahwa performa mesin yang dijual oleh dealer, ataupun trustmark dealer memiliki performa mesin > 1400 CC.

### Kondisi Data
"""

loaded_data.describe()

"""Dari summary statistik data numerik di atas, terlihat bahwa terdapat beberapa kejanggalan data, seperti nilai minimum fuel eficiency = 0

#### Plot missing value
"""

msno.matrix(loaded_data)
plt.show()

"""Dari gambaran data di atas, terlihat bahwa kolom fuel_eficiency, engine, max_power, dan seats memiliki garis-garis putih. Hal ini menunjukkan bahwa terdapat missing value atau data kosong pada kolom tersebut

#### Plot outlier dari data penjualan
"""

sns.boxplot(x=loaded_data["selling_price"])
plt.xlabel("Harga Jual Mobil")
plt.show()

"""Dari grafik tersebut, terlihat bahwa sangat banyak data "harga jual mobil" yang jauh dari rentang normalitas datanya. Rentang tersebut berada di antara 0.0 - 0.2 * 10e7.

#### Plot outlier dari kolom year
"""

sns.boxplot(x=loaded_data["year"])
plt.xlabel("Tahun Pembuatan")
plt.show()

"""Terdapat beberapa data tahun pembuatan mobil yang berada di luar rentang normalitas data.

#### Plot outlier kolom km_driver
"""

sns.boxplot(x=loaded_data["km_driven"])
plt.xlabel("Jarak Tempuh Mobil")
plt.show()

"""Terlihat pada grafik di atas, terdapat beberapa data yang kemunculannya sangat jarang, sehingga sangat berpengaruh terhadap normalitas data

#### Plot outlier fuel_eficiency
"""

sns.boxplot(x=loaded_data["fuel_eficiency"])
plt.xlabel("Efisiensi Bahan Bakar")
plt.show()

"""Hanya terdapat beberapa data efisiensi bahan bakar yang berada di luar rentang normalitas data

#### Plot outlier kolom engine
"""

sns.boxplot(x=loaded_data["engine"])
plt.xlabel("Mesin")
plt.show()

"""Pada data di atas, normalitas data mesin berada pada rentang 500 hingga 2000. Sehingga data yang berada pada rentang diluar itu termasuk ke dalam outlier

#### Plot outlier kolom max_power
"""

sns.boxplot(x=loaded_data["max_power"])

"""## Data Cleaning

### Menghapus Data duplikat
"""

loaded_data.duplicated().sum()

print(len(loaded_data));
loaded_data.drop_duplicates(inplace=True)
print(len(loaded_data))
loaded_data

"""### Menangani missing value dengan mengisinya menggunakan nilai rata-rata dari data

#### Melihat terlebih dahulu apakah data yang missing pada kolom tertentu memiliki nilai missing pada kolom lainnya
"""

# Melihat statistik data
loaded_data.describe()

# Melihat data yang memiliki kolom fuel_eficiency = 0
loaded_data[loaded_data["fuel_eficiency"] == 0]

# Menghitung total masing-masing missing value pada kolom
loaded_data.isna().sum()

# Mengubah missing value menjadi 0
loaded_data.fillna(0, inplace=True)
loaded_data.isna().sum()

# melihat kembali missing value pada datat
filtered_data = loaded_data[loaded_data["fuel_eficiency"] == 0]
filtered_data.iloc[:, -4:]

"""Terlihat bahwa nilai missing value pada kolom fuel efficiency, ternyata juga memiliki missing value pada kolom engine, max_power dan seats dengan total data missing value sebanyak 223"""

# Menghapus missing value
loaded_data = loaded_data[~(loaded_data["fuel_eficiency"] == 0)]
loaded_data

"""#### Plot gambar untuk melihat sebaran data sebelum menangani outliers"""

std = loaded_data["selling_price"].std()
mean = loaded_data["selling_price"].mean()

norm_data = norm.pdf(loaded_data["selling_price"].sort_values(), mean, std);

plt.plot(loaded_data["selling_price"].sort_values(), norm_data);

"""### Menangani Outliers Dengan
Pada bagian ini, teknik statistik akan digunakan untuk menangani masalah outlier, teknik tersebut adalah distribusi normal Z. Teknik ini memiliki pendekatan sebagai berikut:
1. Menentukan tingkat kepercayaan (99% / 95%) atau menentukan taraf signifikansi alpha (1% / 5%)
2. Menghitung masing-masing standar deviasi, rata-rata
3. Menghitung nilai Z pada masing-masing data yang ada di dataframe menggunakan rumus z score untuk populasi
4. Menentukan apakah data yang dihitung berada di dalam rentang a/2 yang merepresentasikan bukan data outlier dengan cara membandingkan absolute dari z_score hitung berada kurang dari z_threshold (+- z_score > z_threshold)
5. Memperbarui dataframe dengan data terbaru yang sudah dilakukan filter untuk menghilangkan outlier
"""

# Membuat fungsi yang menerima 2 parameter dengan default signifikansi alpha 5% / 0.05
def outliers(data, alpha = 0.05):
  # Menghitung rata-rata
  std = np.std(data)
  miu = np.mean(data)
  z_score = [(x - miu) / std for x in data]
  z_threshold = 0
  if(alpha == 0.01):
    z_threshold = 2.58
  elif(alpha == 0.05):
    z_threshold = 1.96
  else:
    z_threshold = 1.96
  data_outlier = [x for i, x in enumerate(data) if abs(z_score[i]) > z_threshold]
  return data_outlier

"""#### Menangani outlier pada kolom selling_price"""

sns.boxplot(x=loaded_data["selling_price"])
plt.show()

print(sorted(outliers(loaded_data["selling_price"])))

print(len(outliers(loaded_data["selling_price"])))

"""Terdapat total 134 data harga penjualan yang berada di luar rentang nilai kritis"""

# Mengupdate data
updated_data = loaded_data[~loaded_data["selling_price"].isin(outliers(loaded_data["selling_price"]))]
updated_data

updated_data.describe().astype(int)

loaded_data.describe().astype(int)

sns.boxplot(x=updated_data["selling_price"])

"""#### Menangani Outlier pada Kolom max_power

##### Mengubah tipe data pada kolom max_power dari tipe data object menjadi numeric / float
"""

updated_data["max_power"] = pd.to_numeric(updated_data["max_power"], errors="coerce")
updated_data.describe()

updated_data.isna().sum()

updated_data = updated_data.dropna()
updated_data.isna().sum()

sns.boxplot(x=updated_data["max_power"])

print(f"Total outlier { len(outliers(updated_data.max_power)) }")
print(sorted(outliers( updated_data["max_power"] )))

updated_data = updated_data[~updated_data["max_power"].isin(outliers(updated_data["max_power"]))]
updated_data

updated_data.describe()

sns.boxplot(x=updated_data["max_power"])

"""### Menangani outlier pada kolom km_driven"""

sns.boxplot(x=updated_data["km_driven"])

updated_data = updated_data[~updated_data["km_driven"].isin(outliers(updated_data["km_driven"]))]
updated_data

sns.boxplot(x=updated_data["km_driven"])

updated_data.describe().astype(int)

"""## Normal Distribution Testing"""

updated_data.describe()

def calculate_normal_data(data, is_save = False):
  std = np.std(data)
  mean = np.mean(data)
  norm_data = norm.pdf(data.sort_values(), mean, std)
  return norm_data

col_index = 0
row_index = 0
fig, ax = plt.subplots(2, 3, figsize=(18, 12))
for i, x in enumerate(updated_data[["selling_price", "km_driven", "fuel_eficiency", "engine", "max_power", "seats"]].columns):
  ax[row_index, col_index].plot(updated_data[x].sort_values(), calculate_normal_data(updated_data[x]), label=x)
  ax[row_index, col_index].set_title(x)
  if col_index == 2:
    row_index += 1
    col_index = 0
    continue
  col_index+=1

updated_data.describe(include="all")

"""## Uji Hipotesis

Uji hipotesis merupakan metode statisitk dalam membuktikan hipotesis berdasarkan data. Langkah sebelumnya telah dilakukan EDA guna mengeksplorasi insight apa saja yang bisa didapatkan pada data. Pada bagian ini, pendekatan statistik akan digunakan untuk menguji hipotesis dalam membuktikan
1. Tipe bahan bakar diesel lebih efisien dalam hal jarak tempuh dibandingkan dengan tipe lainnya
"""

def calculate_z(mean1, mean2, std1, std2, n1, n2, d0 = 0):
  z = (mean1 - mean2 - d0)  / (np.sqrt((std1 ** 2 / n1) + (std2 ** 2 / n2)))
  return z

def conclude_hypotesis(z, a=0.05, side_test="dual"):
  z0, z1 = -1.96, 1.96

  if(side_test == "dual"):
    if a == 0.01:
      z0, z1 = -2.58, 2.58
    if(z > z0 and z < z1):
      print(f"Terima H0 karena {z0:.2f} < {z:.2f} < {z1:.2f}")
    else:
      print(f"Tolak H0 karena {z} diluar rentang [{z0:.2f}, {z1:.2f}]")

  elif(side_test == "right"):
    if a == 0.05:
      z1 = 1.65
    elif a == 0.01:
      z1 = 2.33
    if(z < z1):
      print(f"Terima H0 karena {z:.2f} < {z1:.2f}")
    else:
      print(f"Tolak H0 karena {z:.2f} > {z1:.2f}")
  elif(side_test == "left"):
    if a == 0.05:
      z0 = -1.65
    elif a == 0.01:
      z0 = -2.33

    if(z > z0):
      print(f"Terima H0 karena {z:.2f} > {z0:.2f}")
    else:
      print(f'Tolak H0 karena {z:.2f} < {z1:.2f}')
  return z0, z1

def calculate_z_mean_between_two_statistic(data1, data2, a=0.05, side_test="dual"):
  mean1 = data1.mean()
  mean2 = data2.mean()
  std1 = data1.std()
  std2 = data2.std()
  n1 = data1.count()
  n2 = data2.count()

  z = calculate_z(mean1, mean2, std1, std2, n1, n2)
  z0, z1 = conclude_hypotesis(z, a, side_test=side_test)
  return z0, z1, z

def calculate_z_proportion_between_two_statistics(data1, data2, n1, n2):
  total_data1 = data1.count() #n1
  total_data2 = data2.count() #n2
  p1 = n1 / total_data1 #p1
  p2 = n2 / total_data2 #p2
  p = float(((n1 + n2) / (total_data1 + total_data2)))
  q = float(1 - p)
  z = float((p1 - p2) / np.sqrt((p * q) * ((1 / total_data1) + (1 / total_data2))))
  return z

def calculate_proportion_between_two_statistic(data1, data2, a=0.05, side_test="dual", n1=0, n2=0):
  z = calculate_z_proportion_between_two_statistics(data1, data2, n1, n2)
  conclude_hypotesis(z, a, side_test=side_test)
  return z

def count_sample_using_slovin(population_size, error = 0.05):
  return int(np.ceil(population_size / (1 + population_size * (error ** 2) )))

count_sample_using_slovin(5000, 0.01)

updated_data.describe(include="all")

updated_data.groupby("fuel")["km_driven"].count().plot(kind="bar")
plt.grid(axis="y")
plt.xticks(rotation=45)
plt.show()

"""### Membuktikan tipe bahan bakar diesel lebih efisien dibandingkan dengan tipe lainnya

Hipotesis 0: Tidak ada perbedan efisiensi tipe bahan bakar diesel dengan tipe bahan bakar lainnya

Hipotesis 1: Ada perbedaan dalam hal efisiensi bahan bakar diesel dengan bahan bakar lainnya

#### Diesel dengan CNG

H0: Tidak ada perbedaan efisiensi tipe bahan bakar diesel dengan cng

H1: Ada perbedaan dalam hal efisiensi bahan bakar diesel dengan bahan bakar cng
"""

diesel_data = updated_data[updated_data["fuel"] == "Diesel"]["fuel_eficiency"]
diesel_sample = diesel_data.sample(n=40, random_state=42)

cng_data = updated_data[updated_data["fuel"] == "CNG"]["fuel_eficiency"]
cng_sample = cng_data.sample(n=40, random_state=42)

z0, z1, zhitung = calculate_z_mean_between_two_statistic(diesel_sample, cng_sample, 0.01)

"""Dengan demikian dapat dikatakan bahwa dengan keyakinan sebesar 99% Tidak ada perbedaan efisiensi antara tipe bahan bakar diesel dengan tipe bahan bakar CNG

#### Diesel dengan LPG
"""

lpg_data = updated_data[updated_data["fuel"] == "LPG"]["fuel_eficiency"]
lpg_sample = lpg_data.sample(n=30, random_state=42)

z0, z1, zhitung = calculate_z_mean_between_two_statistic(diesel_sample, lpg_sample, 0.01)

"""Dengan demikian dapat dikatakan bahwa dengan keyakinan sebesar 99% Tidak ada perbedaan efisiensi dalam hal jarak tempuh antara tipe bahan bakar diesel dengan tipe bahan bakar CNG

#### Diesel dengan Petrol
"""

petrol_data = updated_data[updated_data["fuel"] == "Petrol"]["fuel_eficiency"]
petrol_sample = petrol_data.sample(n=40, random_state=42)

z0, z1, zhitung = calculate_z_mean_between_two_statistic(petrol_data, petrol_sample)

updated_data.groupby("fuel")["fuel_eficiency"].mean().plot(kind="bar")
plt.ylabel("fuel_eficiency")
plt.show()

"""Dengan demikian dapat dikatakan bahwa dengan keyakinan sebesar 99% Tidak ada perbedaan efisiensi dalam hal jarak tempuh antara tipe bahan bakar diesel dengan tipe bahan bakar CNG

### Menguji apakah harga mobil otomatic lebih mahal dari mobil manual

H0: Harga mobil dengan transmisi otomatic <= harga mobil dengan transmisi manual

H1: Harga mobil dengan transmisi otomatci > harga mobil dengan transmisi manual
"""

# Membandingkan apakah harga mobil otomatic lebih mahal

manual_data = updated_data[updated_data["transmission"] == "Manual"]["selling_price"]
auto_data = updated_data[updated_data["transmission"] == "Automatic"]["selling_price"]

manual_sample = manual_data.sample(n=40, random_state=42)
auto_sample = auto_data.sample(n=40, random_state=42)

z0, z1, zhitung = calculate_z_mean_between_two_statistic(auto_data, manual_data, side_test="right", a = 0.01)

"""Sehingga dapat dikatakan bahwa dengan keyakinan 99% harga rata-rata mobil dengan transmisi automatic lebih mahal daripada harga mobil dengan transmisi manual

### Menguji rata-rata harga jual mobil berdasarkan bahan bakar

H0: Tidak ada perbedaan antara rata-rata harga jual mobil berdasarkan bahan bakar bensin dengan tipe bahan bakar lainnya

H1: Terdapat perbedaan rata-rata harga jual mobil berdasarkan bahan bakar bensin dengan tipe bahan bakar lainnya
"""

updated_data.groupby("fuel")["selling_price"].mean().plot(kind="bar")

bensin_data = updated_data[updated_data["fuel"] == "Petrol"]["selling_price"]
bensin_sample = bensin_data.sample(n=30, random_state=42)

"""#### Menguji harga rata-rata mobil dengan bahan bakar bensin dengan Diesel"""

diesel_data = updated_data[updated_data["fuel"] == "Diesel"]["selling_price"]
diesel_sample = diesel_data.sample(n=30, random_state=42)

z0, z1, zhitung = calculate_z_mean_between_two_statistic(bensin_sample, diesel_sample)

"""Dapat disimpulkan bahwa dengan keyakinan 95%, terdapat perbedaan harga rata-rata mobil dengan bahan bakar bensin dengan bahan bakar diesel

#### Menguji harga rata-rata mobil bahan bakar bensin dengan LPG
"""

lpg_data = updated_data[updated_data["fuel"] == "LPG"]["selling_price"]
lpg_sample = lpg_data.sample(n=30, random_state=42)

z0, z1, zhitung = calculate_z_mean_between_two_statistic(bensin_sample, lpg_sample)

"""Dapat disimpulkan bahwa dengan keyakinan 95%, terdapat perbedaan harga rata-rata mobil dengan bahan bakar bensin dengan bahan bakar LPG

#### Menguji harga rata-rata mobil bahan bakar bensin dengan CNG
"""

cng_data = updated_data[updated_data["fuel"] == "CNG"]["selling_price"]
cng_sample = cng_data.sample(n=30, random_state=42)

z0, z1, zhitung = calculate_z_mean_between_two_statistic(bensin_sample, cng_sample)

"""Dapat disimpulkan bahwa dengan keyakinan 95%, Tidak ada perbedaan harga rata-rata mobil dengan bahan bakar bensin dengan bahan bakar CNG

### Menguji proporsi tipe seller individu dengan seller dealer

H0: Proporsi individu paling sedikit 60%

H1: Proporsi individu < 60%
"""

seller = updated_data[updated_data["seller_type"].isin(["Individual", "Dealer"])]
seller

sample_seller = seller.sample(n = count_sample_using_slovin(len(seller), error=0.01), random_state=42)
p_group = sample_seller.groupby("seller_type")["seller_type"].count()
n_total_individu = p_group["Individual"]
n_total_dealer = p_group["Dealer"]

individu_seller = sample_seller[sample_seller["seller_type"] == "Individual"]["seller_type"]
dealer_seller = sample_seller[sample_seller["seller_type"] == "Dealer"]["seller_type"]

p = 0.6
p_tuple = n_total_individu / len(sample_seller)

z = (p_tuple - p) / np.sqrt((p * (1 - p)) / len(sample_seller))
conclude_hypotesis(z, a=0.01, side_test="left")

"""Sehingga dapat disimpukan bahwa dengan keyakinan 99%, proporsi penjual mobil yang individu memiliki proporsi minimal paling sedikit 60% (> 0.06)

#### Menguji proporsi tipe seller individu diantara satu sample dengan sampel lainya

H0: Proporsi seller indidu pada sample satu sama dengan proporsi individu yang ada pada sample 2

H1: Proporsi seller individu pada sample satu tidak sama dengan proporsi individu pada sample 2
"""

sample_1 = seller.iloc[:300]["seller_type"]
sample_2 = seller.iloc[300:525]["seller_type"]

n_individu1 = sample_1[sample_1 == "Individual"]
n_individu2 = sample_2[sample_2 == "Individual"]
z = calculate_proportion_between_two_statistic(sample_1, sample_2, 0.05, n1 = n_individu1.count(), n2 = n_individu2.count())

"""Sehingga dapat dikatakan dengan keyakinan 99%, proporsi pada sample 1 tidak sama dengan proporsi pada sample2

### Uji rata-rata harga jual berdasarkan jenis penjual
Asumsi: harga yang dijual oleh individu lebih murah dibandingkan dengan harga jual oleh dealer

H0: Rata-rata harga jual individu >= rata-rata harga jual dealer

H1: Rata-rata harga jual individu < rata-rata harga jual dealer
"""

individu_data = seller[seller["seller_type"] == "Individual"]["selling_price"]
dealer_data = seller[seller["seller_type"] == "Dealer"]["selling_price"]

z0, z1, zhitung = calculate_z_mean_between_two_statistic(individu_data, dealer_data, side_test="left")

updated_data.groupby("seller_type")["selling_price"].mean().plot(kind="bar")

"""### Menguji harga jual tahun 2020 setelah covid 19 lebih murah dibandingkan dengan harga jual tahun 2015 sebelum covid

H0: Harga jual tahun 2020 lebih besar sama dengan harga jual rata-rata tahun 2015

H1: Harga jual tahun 2020 lebih kecil dari harga jual rata-rata tahun 2015
"""

data_2020 = updated_data[updated_data["year"] == 2020]
data_2015 = updated_data[updated_data["year"] == 2015]

sample_2020 = data_2020.sample(n=50, random_state=42)
sample_2015 = data_2015.sample(n=50, random_state=42)

z0, z1, zhitung = calculate_z_mean_between_two_statistic(sample_2020["selling_price"], sample_2015["selling_price"], a=0.01, side_test="left")

"""Sehingga, dengan keyakinan sebesar 99% dapat dikatakan bahwa h0 diterima, artinya adalah bahwa harga jual mobil tahun 2020 setelah covid19 masih tinggi dibandingkan dengan harga jual mobil tahun 2015"""

updated_data.groupby("year")["selling_price"].mean()[[2015, 2020]]

"""### Menguji rata-rata harga jual berdasarkan pemilik

H0: Rata-rata harga jual pemilik pertama lebih besar sama dengan rata-rata harga jual pemilik kedua

H1: Rata-rata harga jual pemilik permata lebih kecil dari rata-rata harga jual pemilik kedua
"""

first_owner_data = updated_data[updated_data["owner"] == "First Owner"]
second_owner_data = updated_data[updated_data["owner"] == "Second Owner"]

first_owner_sample = first_owner_data.sample(n = 500, random_state=42)
second_owner_sample = second_owner_data.sample(n = 500, random_state=42)

z0, z1, zhitung = calculate_z_mean_between_two_statistic(first_owner_sample["selling_price"], second_owner_sample["selling_price"], side_test="left")

"""## Analisis Korelasi"""

numeric_features = updated_data.select_dtypes(include=['number'])
correlation_matrix = numeric_features.corr()

plt.figure(figsize=(10, 5))
sns.heatmap(correlation_matrix, annot=True, cmap='coolwarm', fmt=".2f")
plt.title('Matrix Korelasi pada Data Numerik')
plt.show()

"""## Data Preparation"""

categoricals = ["fuel", "seller_type", "owner", "transmission"]
numericals = ["km_driven", "engine", "max_power", "fuel_eficiency", "seats", "year"]

# Backup updated_data
updated_data_backup = updated_data.copy()
updated_data_backup

updated_data.head()

updated_data.describe()

updated_data.describe(include="all")

print(updated_data["fuel"].unique())
print(updated_data["seller_type"].unique())
print(updated_data["owner"].unique())
print(updated_data["transmission"].unique())

le = LabelEncoder()

ownerEncoder = le.fit_transform(updated_data["owner"])
ownerEncoder

one_hot_encoded = pd.get_dummies(updated_data[["seller_type", "fuel"]])
one_hot_encoded

transmission = updated_data.transmission.apply(lambda x: 1 if x == "Automatic" else 0)
transmission.unique()

updated_data["owner"] = ownerEncoder
updated_data

updated_data["transmission"] = transmission
updated_data

updated_data = pd.concat([updated_data, one_hot_encoded], axis=1)
updated_data = updated_data.drop(columns=["fuel", "seller_type"])
updated_data

updated_data["year"] = 2024 - updated_data["year"]
updated_data = updated_data.drop(columns=["name"])
updated_data

# Convert rupee to IDR per 04/12/2024
updated_data["selling_price"] = updated_data["selling_price"] * 188.02
updated_data

features = updated_data.drop(columns=["selling_price"])
labels = updated_data["selling_price"]

features_column = features.columns
labels_column = labels.name

features.head()

data = features.values
data

m_scaler = MinMaxScaler()

# scaled_data = m_scaler.fit_transform(updated_data[["km_driven", "engine", "max_power", "fuel_eficiency", "seats", "year"]])
# scaled_data
scaled_data = m_scaler.fit_transform(data);
scaled_data

scaled_df = pd.DataFrame(scaled_data, columns=features_column)
scaled_df

x_train, x_test, y_train, y_test = train_test_split(scaled_df, labels, test_size=0.25, random_state=42)

"""## Develop Model Regression"""

numeric_features = updated_data.select_dtypes(include=['number'])
correlation_matrix = numeric_features.corr()

plt.figure(figsize=(10, 5))
sns.heatmap(correlation_matrix, annot=True, cmap='coolwarm', fmt=".2f")
plt.title('Matrix Korelasi pada Data Numerik')
plt.show()

"""### Linear Regression"""

lr = LinearRegression()
lr.fit(x_train[["year"]], y_train)

mae = mean_absolute_error(y_train, lr.predict(x_train[["year"]]))
mae

plt.scatter(y_test, lr.predict(x_test[["year"]]))
plt.show()

"""### KNN Model

"""

from sklearn.neighbors import KNeighborsRegressor

knn_model = KNeighborsRegressor(n_neighbors=9)
knn_model.fit(x_train, y_train)

plt.scatter(y_train, knn_model.predict(x_train))
plt.show()

mae = mean_absolute_error(y_train, knn_model.predict(x_train))
mae

mse = mean_squared_error(y_train, knn_model.predict(x_train))
mse

"""### Random Forest Model

"""

rf_model = RandomForestRegressor(n_estimators=100, random_state=42)
rf_model.fit(x_train, y_train)

mae = mean_absolute_error(y_train, rf_model.predict(x_train))
mae

plt.scatter(y_test, rf_model.predict(x_test))
plt.show()

"""### XGBoost Model"""

xgb_model = xgb.XGBRegressor(n_estimators=100, random_state=42)
xgb_model.fit(x_train, y_train)

xgb_model.score(x_train, y_train)

xgb_mae = mean_absolute_error(y_train, xgb_model.predict(x_train))
xgb_mae

"""### Evaluation"""

r2 = r2_score(y_train, knn_model.predict(x_train))
print(f"R-squared (R2) for KNN model on training data: {r2}")

r2 = r2_score(y_train, rf_model.predict(x_train))
print(f"R-squared (R2) for Random Forest model on training data: {r2}")

r2 = r2_score(y_train, lr.predict(x_train[["year"]]))
print(f"R-squared (R2) for Linear Regression model on training data: {r2}")

from sklearn.metrics import mean_absolute_percentage_error
print('Approximation error =', np.round((100 * mean_absolute_percentage_error(y_test, rf_model.predict(x_test))), 2), '%')

importances = rf_model.feature_importances_
features = x_train.columns

features_with_importances = pd.DataFrame({'Features':features, 'Importance':importances})

features_with_importances = features_with_importances.sort_values(['Importance'], ascending = False)
features_with_importances

mse_lr = mean_squared_error(y_test, lr.predict(x_test[["year"]]))
print(f"MSE for Linear Regression: {mse_lr}")

mse_knn = mean_squared_error(y_test, knn_model.predict(x_test))
print(f"MSE for KNN: {mse_knn}")

mse_rf = mean_squared_error(y_test, rf_model.predict(x_test))
print(f"MSE for Random Forest: {mse_rf}")

rmse_lr = np.sqrt(mse_lr)
print(f"RMSE for Linear Regression: {rmse_lr}")

rmse_knn = np.sqrt(mse_knn)
print(f"RMSE for KNN: {rmse_knn}")

rmse_rf = np.sqrt(mse_rf)
print(f"RMSE for Random Forest: {rmse_rf}")

"""#### Try model with no outlier data"""

Q1 = updated_data["selling_price"].quantile(0.25)
Q3 = updated_data["selling_price"].quantile(0.75)

IQR = Q3 - Q1

lower_bound = Q1 - 1.5 * IQR
upper_bound = Q3 + 1.5 * IQR

cleaned_data = updated_data[(updated_data["selling_price"] >= lower_bound) & (updated_data["selling_price"] <= upper_bound)]
cleaned_data

feats = updated_data.drop(columns=["selling_price"])
lab = updated_data["selling_price"]
feats

scaled = m_scaler.fit_transform(feats)
scaled

scaled_df2 = pd.DataFrame(scaled, columns=feats.columns)
scaled_df2

xt_train, xt_test, yt_train, yt_test = train_test_split(scaled_df2, lab, test_size=0.2, random_state=42)

rf_model2 = RandomForestRegressor(n_estimators=100, random_state=42)
rf_model2.fit(xt_train, yt_train)

plt.scatter(yt_train, rf_model2.predict(xt_train))
plt.show()

model_results = {
    "model": ["Random Forest", "Random Forest2"],
    "mse": [mse_rf, mean_squared_error(yt_train, rf_model2.predict(xt_train))],
    "mae": [mae, mean_absolute_error(yt_train, rf_model2.predict(xt_train))],
}

df = pd.DataFrame(model_results)
df

"""### Hypertuning Model"""

grid_params = {"n_estimators" : [50,60,70,80,90,100], "max_depth" : [4,8,16,32,64], "random_state" : [42, 99]}
grid = GridSearchCV(RandomForestRegressor(), grid_params, cv=5, verbose=2, scoring="neg_mean_absolute_error")
grid.fit(x_train, y_train)
print(grid.best_params_)

rf_model_tuned = RandomForestRegressor(n_estimators=90, random_state=42, max_depth=16)
rf_model_tuned.fit(x_train, y_train)

rf_model_tuned_mae = mean_absolute_error(y_train, rf_model_tuned.predict(x_train))
rf_model_tuned_mse = mean_squared_error(y_train, rf_model_tuned.predict(x_train))
rf_model_tuned_mae_test = mean_absolute_error(y_test, rf_model_tuned.predict(x_test))
rf_model_tuned_mse_test = mean_squared_error(y_test, rf_model_tuned.predict(x_test))

datas = {
    "model": ["Random Forest", "Random Forest Tuned"],
    "mae_train": [mean_absolute_error(y_train, rf_model.predict(x_train)), rf_model_tuned_mae],
    "mae_test": [mean_absolute_error(y_test, rf_model.predict(x_test)), rf_model_tuned_mae_test],
}

df = pd.DataFrame(datas)
df = df.round(2)
df